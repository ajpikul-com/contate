#!/bin/bash

# DICTIONARY

dbg "defining dictionary"
# d_reload_from_file - will just load the file into the map. It's called during d_start and probably after running another contate
function d_reload_from_file {
	dbg "d_reload()"
	unset D_CACHE
	declare -A D_CACHE
	while IFS= read -r line; do
		dbg "Line: $line; Key: ${line%%=*} and value: ${line#*=}"
		D_CACHE["${line%%=*}"]="${line#*=}"
	done < "${D_FILE}"
	unset D_CACHE_KEYS
	unset D_CACHE_VALS
	export D_CACHE_VALS
  export D_CACHE_KEYS="${!D_CACHE[*]}"
	for key in "${!D_CACHE[@]}"; do
		D_CACHE_VALS+="$(base64 <<< "${D_CACHE[$KEY]}") "
	done
	D_CACHE_VALS="${D_CACHE_VALS% }"
	dbg "Keys: ${D_CACHE_KEYS}"
	dbg "Vals${D_CACHE_VALS}"
	dbg "d_reload: declare -p D_CACHE: $(declare -p D_CACHE)"
}

# d_rewrite - will write the map to the file, should be called anytime we modify the cache
function d_rewrite {
	dbg "d_rewrite()"
	echo -n "" > "${D_FILE}"
	dbg "array keys: ${!D_CACHE[@]}"
	dbg "array values: ${D_CACHE[@]}"
	for key in "${!D_CACHE[@]}"; do
		dbg "writing $key"
		echo "$key"="${D_CACHE[$key]}" >> "${D_FILE}"
	done
	dbg "Wrote file:$(cat ${D_FILE})"
}

# d_start - should be called at the beginning of any contate script
function d_start {
	dbg "d_start()"
	if [[ -z "${D_MASTER}" ]]; then
		D_MASTER=$$
		D_FILE="$(mktemp)"
		# TODO: check result?
	elif [[ ! -f ${D_FILE} ]]; then
		# TODO: err,  there is no file but master is set? it should have declared it
		return 1
		:
	fi
	export D_MASTER
	export D_FILE
	dbg "D_MASTER: ${D_MASTER}"
	dbg "D_FILE: ${D_FILE}"
	d_reload
}

# d_clean - should be set to trap EXIT/FINISH
function d_clean {
	dbg "d_clean()"
	if [[ "$$" = "${D_MASTER}" && -f "${D_FILE}" ]]; then
		rm "${D_FILE}"
	fi
}


# d_get KEY - gets key or ""
function d_get {
	# TODO: check and reload D_CACHE
	dbg "d_get($1)"
	dbg "Got: ${D_CACHE[$1]}"
	echo -ne "${D_CACHE[$1]}"
}

# d_set KEY VALUE - sets KEY to VALUE
function d_set {
	dbg "d_set($1, $2)"
	# TODO: keys cannot contain spaces
	D_CACHE["$1"]="$2"
	dbg "Declare -p D_CACHE $(declare -p D_CACHE)"
	dbg "Ran: D_CACHE[\"$1\"]=\"$2\""
	dbg "array keys: ${!D_CACHE[*]}"
	dbg "array values: ${D_CACHE[*]}"
	dbg "array value for key $1: ${D_CACHE[$1]}"
	d_rewrite
	dbg "array keys: ${!D_CACHE[*]}"
	dbg "array values: ${D_CACHE[*]}"
}

# d_exists KEY - returns whether or not key exists
function d_exists {
	dbg "d_exists($1)"
	return $([ ${D_CACHE[$1]+_} ])
}

# d_del KEY - deletes the keyu
function d_del {
	dbg "d_del($1)"
	unset D_CACHE["$1"]
	d_rewrite
}


export -f d_start d_clean d_get d_set d_del d_reload d_rewrite
