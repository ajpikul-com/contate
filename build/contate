#!/bin/bash
# Multiple shebangs are fine :-)

#UTIL

# error function checks?

if [ -z "$CONTATE_DEBUG" ]; then
	export CONTATE_DEBUG=false
fi

# must will fail the last exit code isn't true
must(){
	if ! $?; then
		err $1
		exit 1
	fi
}

# should will dbg if the last exit code isn't true
should(){
	if ! $?; then
		dbg $1
	fi
}

dbg(){
	if $CONTATE_DEBUG; then
		>&2 echo "DEBUG: ${@}"
	fi
}
dbg "defining utils"
err(){
	if ! $CONTATE_QUIET; then
		>&2 echo "ERR: ${@}"
	fi
}

usage(){
	if ! $CONTATE_QUIET; then
		>&2 echo "USAGE: " # TODO
	fi
}
dbg "util defined"

def(){
	if [ -z "${!1}" ]; then
		dbg "Setting default for variable ${1} to ${2}"
		eval "${1}"="${2}"
	fi
}
#!/bin/bash

# DICTIONARY

dbg "defining dictionary"
# d_reload - will just load the file into the map. It's called during d_start and probably after running another contate
function d_reload {
	dbg "d_reload()"
	unset D_CACHE
	declare -A D_CACHE
	while IFS= read -r line; do
		D_CACHE["${line%%=*}"]="${line#*=}"
	done < "${D_FILE}"
	export D_CACHE
}

# d_rewrite - will write the map to the file, should be called anytime we modify the cache
function d_rewrite {
	dbg "d_rewrite()"
	echo "" > "${D_FILE}"
	for key in "${!array[@]}"; do
		echo "$i"="${array[$1]}" >> "${D_FILE}"
	done
}

# d_start - should be called at the beginning of any contate script
function d_start {
	dbg "d_start()"
	if [[ -z "${D_MASTER}" ]]; then
		D_MASTER=$$
		D_FILE="$(mktemp)"
		# TODO: check result?
	elif [[ ! -f ${D_FILE} ]]; then
		# TODO: err,  there is no file but master is set? it should have declared it
		return 1
		:
	fi
	export D_MASTER
	export D_FILE
	dbg "D_MASTER: ${D_MASTER}"
	dbg "D_FILE: ${D_FILE}"
	d_reload
}

# d_clean - should be set to trap EXIT/FINISH
function d_clean {
	dbg "d_clean()"
	if [[ "$$" = "${D_MASTER}" && -f "${D_FILE}" ]]; then
		rm "${D_FILE}"
	fi
}


# d_get KEY - gets key or ""
function d_get {
	dbg "d_get()"
	echo -ne "${D_CACHE[$1]}"
}

# d_set KEY VALUE - sets KEY to VALUE
function d_set {
	dbg "d_set()"
	# TODO: keys cannot contain spaces
	D_CACHE[$1]="$2"
	d_rewrite
}

# d_exists KEY - returns whether or not key exists
function d_exists {
	dbg "d_exists()"
	return $([ ${D_CACHE[$1]+_} ])
}

# d_del KEY - deletes the keyu
function d_del {
	dbg "d_del()"
	unset D_CACHE["$1"]
	d_rewrite
}


export -f d_start d_clean d_get d_set d_del d_reload
function c_execute {
	dbg "Running $TMP_SCRIPT"
	SCRIPT_OUTPUT=""
	chmod +x "$TMP_SCRIPT"
	must "Failed to set +x on $TMP_SCRIPT"
	if [ "$IS_C" = true ]; then
		dbg "It is C"
		mv "$TMP_SCRIPT" "$TMP_SCRIPT".c
		must "Couldn't rename $TMP_SCRIPT for C"
		TMP_SCRIPT="$TMP_SCRIPT".c
	fi
	SCRIPT_OUTPUT="$($TMP_SCRIPT)"
	must "Script output failed"
	while IFS='' read -r scriptoutput2; do
		CONTATED_FILE+="$INDENTATION""$scriptoutput2"'\n'
	done <<< "$SCRIPT_OUTPUT"
	unset IS_C
}


def CONTATE_START_REGEX '^(.*)#!(?:/.+)+$'
def CONTATE_END_REGEX '^(?:\s*)!#(.*)$'
def CONTATE_INLINE '^.*#!($[{|\(].+[}|\)])!#.*$'
# 1- Target file - realpath is fine, are we being passed that? it's fine to set it
# 2- Output file- this needs to be a realpath + any directories that have been or need to be made
contate_file(){ 
	dbg "TARGET=$1"
	dbg "OUTPUT=$2"
	TARGET="$1"
	OUTPUT="$1"
	CONTATED_FILE=""
	IS_C=false
	while IFS='' read -r line || [[ -n "$line" ]]; do # if the EOF comes with no NL, second term helps
		# IN SCRIPT
		if [ -n "${TMP_SCRIPT}" ]; then
			# END BLOCK
			if [[ "$line" =~ $CONTATE_END_REGEX ]]; then
				dbg "END SCRIPT"
				c_execute # TODO what do with output?
				CONTATED_FILE="${CONTATED_FILE%'\n'}"
				CONTATED_FILE+="${BASH_REMATCH[1]}"'\n'
				unset TMP_SCRIPT
			else
				echo "${line#$INDENTATION}" >> "$TMP_SCRIPT"
			fi
		# Start Contate Block
		elif [[ "$line" =~ $CONTATE_START_REGEX ]] && [ $BASH_REMATCH[1] != "*#" ]; then
			dbg "START SCRIPT"
			if grep -qe "tcc -run" <<< "$line"; then
				IS_C=true
			fi
			# set filetype
			TMP_SCRIPT="$(mktemp)"
			echo ${line#${BASH_REMATCH[1]}} > "$TMP_SCRIPT"
			CONTATED_FILE+="${BASH_REMATCH[1]}"
			[[ "$line" =~ ^(\s*) ]]
			INDENTATION="${BASH_REMATCH[1]}"
		# Direct copy
		elif [[ "$line" =~ $CONTATE_INLINE ]];; then
			dbg "Inline replacement: ${BASH_REMATCH[1]}"
			INLINE_OUTPUT="$(eval "$BASH_REMATCH[1]")"
			must "$BASH_REMATCH[1] failed to be eval'ed"
			CONTATED_FILE="${line/"#!$BASH_REMATCH[1]!#"/$INLINE_OUTPUT}"'\n'
		else
			CONTATED_FILE+="$line"'\n'
		fi
	done < "$TARGET"
	if [ "$TMP_SCRIPT" != "" ]; then
		echo -ne "${CONTATED_FILE}" > "$2"
		dbg "WROTE SCRIPT"
	else
		err "Unexpected EOF in ${TARGET}"
		exit 1
	fi
}
#!/bin/bash

# BASIC INITIALIZATIONS

shopt -s nullglob globstar

# An array of all the variables we've created
declare -a CONTATE_TEMP_FILE_LIST

# contate_clean is a function to delete those temps and call dictionary's clean too, which celetes the variable temp
function contate_clean {
	d_clean
	for file in "${CONTATE_TEMP_FILE_LIST[@]}"; do
		dbg "rm'ing $file"
		rm "$file"
		should "$file didn't delete properly"
	done
}
dbg "d_start()"
d_start
dbg "trap contate_clean()"
trap contate_clean EXIT

# SET VARIABLES

def CONTATE_RECURSE false
def CONTATE_QUIET false
def CONTATE_PATTERN '(.*).contate$'
def CONTATE_DRY false
export CONTATE_QUIET CONTATE_RECURSE CONTATE_PATTERN CONTATE_OUTPUT CONTATE_DRY

while getopts ":o:p:dqrh" opt; do
	dbg "Getopts iteration"
	case "$opt" in
	d)
		CONTATE_DRY=true
		;;
	o)
		CONTATE_OUTPUT="${OPTARG}"
		;;
	r)
		CONTATE_RECURSE=true
		;;
	p)
		CONTATE_PATTERN="${OPTARG}"
		;;
	q)
		CONTATE_QUIET=true
		;;
	h)
		CONTATE_QUIET=false
		usage
		exit 0
		;;
	*)
		err	"Unkown opt: $OPTARG"
		usage 
		exit 1
		;;
	esac
done

dbg "All arguments passed:: ${*}"	

shift "$(( OPTIND - 1 ))"

dbg "CONTATE_DRY=${CONTATE_DRY}"
dbg "CONTATE_OUTPUT=${CONTATE_OUTPUT}"
dbg "CONTATE_RECURSE=${CONTATE_RECURSE}"
dbg "CONTATE_DEBUG=${CONTATE_DEBUG}"
dbg "CONTATE_QUIET=${CONTATE_QUIET}"
dbg "CONTATE_PATTERN=${CONTATE_PATTERN}"
dbg "CONTATE FILES: ${*}"

# VALIDATE FLAGS

if ${CONTATE_QUIET} && ${CONTATE_DEBUG}; then
	err "You cannot set both quiet and debug"
	exit 1
fi

if [[ -d "${CONTATE_OUTPUT}" ]]; then
	if [[ -w "${CONTATE_OUTPUT}" ]]; then
		dbg "CONTATE_OUTPUT is a directory"
		CONTATE_OUTPUT="$(realpath "${CONTATE_OUTPUT}")"
	else
		err "Can't write to ${CONTATE_OUTPUT}"
		exit 1
	fi
elif [ -z "${CONTATE_OUTPUT}" ] || [ "${CONTATE_OUTPUT}" = "/dev/stdout" ]; then
	dbg "CONTATE_OUTPUT not set, so stdout"
	CONTATE_OUTPUT="/dev/stdout"
else
	err "Contate cannot currently create directories or use a custom naming scheme for files beyond -p"
	usage
	exit
fi
dbg "CONTATE_OUTPUT reset to: ${CONTATE_OUTPUT}"

for target; do
	if [[ -d "${target}" ]] && ! $CONTATE_RECURSE; then
		err "${target} is a directory but didn't specify -r"
		usage
		exit 1
	fi
done

# RECURSE THROUGH INPUTS
for target; do
	if [ "$CONTATE_MASTER" = "$$" ]; then
		export REMOVEABLE_PATH="$(dirname $(realpath $target))"/
	fi
	if [[ -d "${target}" && -x "${target}" && -r "${target}" ]]; then
		dbg "TARGET DIRECTORY: ${target}"
		${0} ${target}/*
		must "Contate failed on one of ${target}/*"
	elif [[ -f "${target}" && -r "${target}" ]]; then
		target="$(realpath $target)"
		dbg "TARGET FILE: ${target}"
		if [[ "${target}" =~ ${CONTATE_PATTERN} ]]; then
			if [ "${CONTATE_OUTPUT}" != "/dev/stdout" ]; then
				if [ -n "${BASH_REMATCH[1]}" ]; then
					OUTPUT_SUBPATH="${BASH_REMATCH[1]#${REMOVABLE_PATH}}"
				else
					OUTPUT_SUBPATH="${target#${REMOVABLE_PATH}}"
				fi
				CONTATE_OUTPUT="${CONTATE_OUTPUT}/${OUTPUT_SUBPATH}"
				dbg "Is a contate file! it's output is: ${CONTATE_OUTPUT}"
			fi
			if ! $CONTATE_DRY; then 
				contate_file "${target}" "${CONTATE_OUTPUT}" 
				must "Contate file failed somewhere on ${target} to ${CONTATE_OUTPUT}"
				d_reload
			fi
		fi
	fi
done
