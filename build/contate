#!/bin/bash
# Multiple shebangs are fine :-)

#UTIL

# error function checks?

if [ -z "$CONTATE_DEBUG" ]; then
	export CONTATE_DEBUG=false
fi

if $CONTATE_DEBUG; then
	# Don't think tput works unless we're piping directly to console
	export CoC="$(tput bold)c$(tput sgr0)"
	export CoS="$(tput bold)s$(tput sgr0)"
	export CoE="$(tput bold)e$(tput sgr0)"
	export CoP="$(tput bold)p$(tput sgr0)"
	export CoI="$(tput bold)i$(tput sgr0)"
else
	unset CoC CoS CoE CoP CoI
fi

dbg(){
	if $CONTATE_DEBUG; then
		>&2 echo "DEBUG: ${@}"
	fi
}

# must will fail the last exit code isn't true
must(){
	dbg "must passed $1 for $2"
	if [ $1 -ne 0 ]; then
		err $2
		exit 1
	fi
}

# should will dbg if the last exit code isn't true
should(){
	if [ $1 -ne 0 ]; then
		dbg $2
	fi
}

dbg "defining utils"
err(){
	if ! $CONTATE_QUIET; then
		>&2 echo "ERR: ${@}"
	fi
}

usage(){
	if ! $CONTATE_QUIET; then
		>&2 echo "USAGE: " # TODO
	fi
}
dbg "util defined"
#!/bin/bash

# DICTIONARY

dbg "defining dictionary"
# d_reload - will just load the file into the map. It's called during d_start and probably after running another contate
function d_reload {
	dbg "d_reload()"
	unset D_CACHE
	declare -A D_CACHE
	while IFS= read -r line; do
		D_CACHE["${line%%=*}"]="${line#*=}"
	done < "${D_FILE}"
	export D_CACHE
}

# d_rewrite - will write the map to the file, should be called anytime we modify the cache
function d_rewrite {
	dbg "d_rewrite()"
	echo "" > "${D_FILE}"
	for key in "${!array[@]}"; do
		echo "$i"="${array[$1]}" >> "${D_FILE}"
	done
}

# d_start - should be called at the beginning of any contate script
function d_start {
	dbg "d_start()"
	if [[ -z "${D_MASTER}" ]]; then
		D_MASTER=$$
		D_FILE="$(mktemp)"
		# TODO: check result?
	elif [[ ! -f ${D_FILE} ]]; then
		# TODO: err,  there is no file but master is set? it should have declared it
		return 1
		:
	fi
	export D_MASTER
	export D_FILE
	dbg "D_MASTER: ${D_MASTER}"
	dbg "D_FILE: ${D_FILE}"
	d_reload
}

# d_clean - should be set to trap EXIT/FINISH
function d_clean {
	dbg "d_clean()"
	if [[ "$$" = "${D_MASTER}" && -f "${D_FILE}" ]]; then
		rm "${D_FILE}"
	fi
}


# d_get KEY - gets key or ""
function d_get {
	dbg "d_get()"
	echo -ne "${D_CACHE[$1]}"
}

# d_set KEY VALUE - sets KEY to VALUE
function d_set {
	dbg "d_set()"
	# TODO: keys cannot contain spaces
	D_CACHE[$1]="$2"
	d_rewrite
}

# d_exists KEY - returns whether or not key exists
function d_exists {
	dbg "d_exists()"
	return $([ ${D_CACHE[$1]+_} ])
}

# d_del KEY - deletes the keyu
function d_del {
	dbg "d_del()"
	unset D_CACHE["$1"]
	d_rewrite
}


export -f d_start d_clean d_get d_set d_del d_reload
function c_execute {
	dbg "Running $TMP_SCRIPT"
	SCRIPT_OUTPUT=""
	chmod +x "$TMP_SCRIPT"
	must $? "Failed to set +x on $TMP_SCRIPT"
	if [ "$IS_C" = true ]; then
		dbg "It is C"
		mv "$TMP_SCRIPT" "$TMP_SCRIPT".c
		must $? "Couldn't rename $TMP_SCRIPT for C"
		TMP_SCRIPT="$TMP_SCRIPT".c
	fi
	set -e
	SCRIPT_OUTPUT="$($TMP_SCRIPT)"
	must $? "Script output failed"
	TOTAL_LINES=$(echo "$SCRIPT_OUTPUT"| wc -l)
	i=0
	set +e
	while IFS='' read -r scriptoutput2; do
		dbg "Line Number:$i / $TOTAL_LINES"
		i=$(( i + 1 ))
		if [ $i -gt 1 ]; then
			echo -n "${CoP}${INDENTATION}${scriptoutput2}" >> "$OUTPUT"
		else
			echo -n "${CoP}${scriptoutput2}" >> "$OUTPUT"
		fi
		if [ $i -lt $TOTAL_LINES ]; then
			echo "" >> "$OUTPUT"
		else
			dbg "Was last line"
		fi
	done <<< "$SCRIPT_OUTPUT"
	unset IS_C
}


[ -z "${CONTATE_START_REGEX}" ] && CONTATE_START_REGEX='^(.*)#!(/.+)$'
[ -z "${CONTATE_END_REGEX}" ] && CONTATE_END_REGEX='^([[:space:]]*)!#(.*)$'
[ -z "${CONTATE_INLINE}" ] && CONTATE_INLINE='^.*#!\$\((.+)\)!#.*$'
# 1- Target file - realpath is fine, are we being passed that? it's fine to set it
# 2- Output file- this needs to be a realpath + any directories that have been or need to be made
contate_file(){ 
	dbg "TARGET=$1"
	dbg "OUTPUT=$2"
	TARGET="$1"
	OUTPUT="$2"
	IS_C=false
	unset TMP_SCRIPT
	while IFS='' read -r line || [[ -n "$line" ]]; do # if the EOF comes with no NL, second term helps
		# IN SCRIPT
		[[ "$line" =~ $CONTATE_START_REGEX ]] && dbg "(NOTE) Start: '$line' with '${BASH_REMATCH[1]}'"
		[[ "$line" =~ $CONTATE_END_REGEX ]] && dbg "(NOTE) End: '$line' with '${BASH_REMATCH[2]}'"
		[[ "$line" =~ $CONTATE_INLINE ]] && dbg "(NOTE) Inline:'$line' with '${BASH_REMATCH[1]}'"
		if [ -n "${TMP_SCRIPT}" ]; then
			# END BLOCK..
			if [[ "$line" =~ $CONTATE_END_REGEX ]]; then
				dbg "END SCRIP on '$line' with rematch '${BASH_REMATCH[2]}'"
				c_execute # TODO what do with output?
				echo "${CoE}${BASH_REMATCH[2]}" >> ${OUTPUT}
				unset TMP_SCRIPT
			else
				dbg "Process line '$line'"
				echo "${line#$INDENTATION}" >> "$TMP_SCRIPT"
			fi
		# Start Contate Block
		elif [[ "$line" =~ $CONTATE_START_REGEX ]] && [[ "${BASH_REMATCH[1]}" != *"#" ]]; then
			dbg "START SCR on '$line' with rematch: '${BASH_REMATCH[1]}'"
			if grep -qe "tcc -run" <<< "$line"; then
				IS_C=true
			fi
			# set filetype
			TMP_SCRIPT="$(mktemp)"
			echo "${line#${BASH_REMATCH[1]}}" >> "$TMP_SCRIPT"
			echo -n "${CoS}${BASH_REMATCH[1]}" >>"$OUTPUT"
			[[ "$line" =~ ^([[:space:]]*) ]]
			INDENTATION="${BASH_REMATCH[1]}"
			dbg "Captured indentation: '$INDENTATION'"
		# Direct copy
		elif [[ "$line" =~ $CONTATE_INLINE ]]; then
			dbg "Inline replacement: '${BASH_REMATCH[1]}'"
			set -e
			INLINE_OUTPUT="$(eval "${BASH_REMATCH[1]}")"
			must $? "${BASH_REMATCH[1]} failed to be eval'ed"
			dbg "INLINE OUTPUT: $INLINE_OUTPUT"
			set +e
			echo "${CoI}${line/\#\!$\(${BASH_REMATCH[1]})\!#/$INLINE_OUTPUT}" >> "$OUTPUT"
		else
			echo "${CoC}$line" >> "$OUTPUT"
		fi
	done < "$TARGET"
	if [ -z "$TMP_SCRIPT" ]; then
		dbg "WROTE SCRIPT"
	else
		err "Unexpected EOF in ${TARGET}"
		exit 1
	fi
}
#!/bin/bash

# BASIC INITIALIZATIONS

shopt -s nullglob globstar

# An array of all the variables we've created
declare -a CONTATE_TEMP_FILE_LIST

# contate_clean is a function to delete those temps and call dictionary's clean too, which celetes the variable temp
function contate_clean {
	d_clean
	for file in "${CONTATE_TEMP_FILE_LIST[@]}"; do
		dbg "rm'ing $file"
		rm "$file"
		should "$file didn't delete properly"
	done
}
dbg "d_start()"
d_start
dbg "trap contate_clean()"
trap contate_clean EXIT

# SET VARIABLES

[ -z "${CONTATE_RECURSE}" ] && CONTATE_RECURSE=false
[ -z "${CONTATE_QUIET}" ] && CONTATE_QUIET=false
[ -z "${CONTATE_PATTERN}" ] && CONTATE_PATTERN='(.*).contate$'
[ -z "${CONTATE_DRY}" ] && CONTATE_DRY=false
export CONTATE_QUIET CONTATE_RECURSE CONTATE_PATTERN CONTATE_OUTPUT CONTATE_DRY

while getopts ":o:p:dqrh" opt; do
	dbg "Getopts iteration"
	case "$opt" in
	d)
		CONTATE_DRY=true
		;;
	o)
		CONTATE_OUTPUT="${OPTARG}"
		;;
	r)
		CONTATE_RECURSE=true
		;;
	p)
		CONTATE_PATTERN="${OPTARG}"
		;;
	q)
		CONTATE_QUIET=true
		;;
	h)
		CONTATE_QUIET=false
		usage
		exit 0
		;;
	*)
		err	"Unkown opt: $OPTARG"
		usage 
		exit 1
		;;
	esac
done

dbg "All arguments passed:: ${*}"	

shift "$(( OPTIND - 1 ))"

dbg "CONTATE_DRY=${CONTATE_DRY}"
dbg "CONTATE_OUTPUT=${CONTATE_OUTPUT}"
dbg "CONTATE_RECURSE=${CONTATE_RECURSE}"
dbg "CONTATE_DEBUG=${CONTATE_DEBUG}"
dbg "CONTATE_QUIET=${CONTATE_QUIET}"
dbg "CONTATE_PATTERN=${CONTATE_PATTERN}"
dbg "CONTATE FILES: ${*}"

# VALIDATE FLAGS

if ${CONTATE_QUIET} && ${CONTATE_DEBUG}; then
	err "You cannot set both quiet and debug"
	exit 1
fi

if [[ -d "${CONTATE_OUTPUT}" ]]; then
	if [[ -w "${CONTATE_OUTPUT}" ]]; then
		dbg "CONTATE_OUTPUT is a directory"
		CONTATE_OUTPUT="$(realpath "${CONTATE_OUTPUT}")"
	else
		err "Can't write to ${CONTATE_OUTPUT}"
		exit 1
	fi
elif [ -z "${CONTATE_OUTPUT}" ] || [ "${CONTATE_OUTPUT}" = "/dev/stdout" ]; then
	dbg "CONTATE_OUTPUT not set, so stdout"
	CONTATE_OUTPUT="/dev/stdout"
else
	err "Contate cannot currently create directories or use a custom naming scheme for files beyond -p"
	usage
	exit
fi
dbg "CONTATE_OUTPUT reset to: ${CONTATE_OUTPUT}"

for target; do
	if [[ -d "${target}" ]] && ! $CONTATE_RECURSE; then
		err "${target} is a directory but didn't specify -r"
		usage
		exit 1
	fi
done

# RECURSE THROUGH INPUTS
for target; do
	if [ "$D_MASTER" = "$$" ]; then
		if [ -f "$target" ]; then
			export REMOVABLE_PATH="$(dirname $(realpath $target))"/
		else
			export REMOVABLE_PATH="$(realpath $target)"/
		fi
		dbg "REMOVABLE_PATH: $REMOVABLE_PATH"
	fi
	if [[ -d "${target}" && -x "${target}" && -r "${target}" ]]; then
		dbg "TARGET DIRECTORY: ${target}"
		${0} $(realpath ${target})/*
		must $? "Contate failed on one of $(realpath ${target})/*"
	elif [[ -f "${target}" && -r "${target}" ]]; then
		target="$(realpath $target)"
		dbg "TARGET FILE: ${target}"
		if [[ "${target}" =~ ${CONTATE_PATTERN} ]]; then
			if [ "${CONTATE_OUTPUT}" != "/dev/stdout" ]; then
				if [ -n "${BASH_REMATCH[1]}" ]; then
					dbg "Calculating output: "
					dbg "BASH_REMATCH: ${BASH_REMATCH[1]}"
					dbg "REMOVABLE_PATH: ${REMOVABLE_PATH}"
					OUTPUT_SUBPATH="${BASH_REMATCH[1]#${REMOVABLE_PATH}}"
				else
					dbg "Calculating output: "
					dbg "target: ${target}"
					dbg "REMOVABLE_PATH: ${REMOVABLE_PATH}"
					OUTPUT_SUBPATH="${target#${REMOVABLE_PATH}}"
				fi
				SPECIFIC_OUTPUT="${CONTATE_OUTPUT}/${OUTPUT_SUBPATH}"
				dbg "Is a contate file! it's output is: ${SPECIFIC_OUTPUT}"
				mkdir -p "$(dirname ${SPECIFIC_OUTPUT})"
			fi
			if ! $CONTATE_DRY; then 
				contate_file "${target}" "${SPECIFIC_OUTPUT}" 
				must $? "Contate file failed somewhere on ${target} to ${SPECIFIC_OUTPUT}"
				d_reload
			fi
		fi
	fi
done
