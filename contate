#!/bin/bash

set -a

if [ -z "${TMP_VAR}" ]; then
	TMP_VAR=$(mktemp)
	TMP_OWNER=true
else
	TMP_OWNER=false
fi
dbg(){
	if $DEBUG; then
		>&2 echo $1
	fi
}

err(){
	if $QUIET; then
		>&2 echo $1
	fi
}
usage(){
	echo "Usage: $1" 1>&2
	if $TMP_OWNER && test -f $TMP_VAR; then
		rm $TMP_VAR
		dbg "rmed"
	fi
	exit
}

# the following just compares the real path against each , deliminted "copy" argument
# may lead to some untuitive behaviors, but since it's relying on common programs to parse
# it will still be pretty intuitive
cmp(){
	dbg "Check cmp $1 $2"
	for i in $2; do
		dbg "$i = $1"
		if [ $i -ef $1 ]; then
			dbg "copying!"
			return 0
		fi
	done
	return 1
}

setvar(){
	dbg "Setting var"
	if [ -f ${TMP_VAR} ]; then
		if grep ${TMP_VAR} -e "$1="; then
			sed -i ${TMP} -e "s/${1}=.*/{$1}=${2}/"
		else
			echo "${1}=${2}" >> ${TMP_VAR}
		fi
		dbg "temp file:"
		dbg "$(cat ${TMP_VAR})"
		dbg "temp file<-:"
	else
		exit
	fi
}
getvar(){
	if [ -f ${TMP_VAR} ]; then
		dbg "find $1 in cat: $(cat ${TMP_VAR})"
		dbg "grep: $(grep ${TMP_VAR} -e "$1=")"
		echo $(grep ${TMP_VAR} -e "$1=" | cut -d '=' -f 2-)
	fi
}
testfunction(){
	echo "not much"
}

contate_file(){ #1 = file to read; ret=CONTATED_FILE (currently processing)
	unset TMP_SCRIPT
	FILE_TO_CONTATE=$1
	CONTATED_FILE=""
	while IFS= read -r line || [[ -n "$line" ]]
	do
# single-line contate commands > shebang+contate command, but parser programming is work
		dbg "Line read: $line"
		if [ -n "${TMP_SCRIPT}" ]; then
			if [[ "$(awk '{$1=$1};1' <<< "$line")" == ":contate -->" ]]; then
				dbg "$(cat $TMP_SCRIPT)"
				chmod +x $TMP_SCRIPT
				if [ "$IS_C" = "true" ]; then
					mv "$TMP_SCRIPT" "$TMP_SCRIPT".c
					TMP_SCRIPT="$TMP_SCRIPT".c
				fi
				CONTATED_FILE+=$($TMP_SCRIPT)'\n'
				#rm $TMP_SCRIPT
				TMP_SCRIPT=""
				dbg "script closed"
			else
				if grep -e "tcc -run" <<< $line; then
					IS_C=true
				fi
				echo "$line" >> $TMP_SCRIPT
				dbg "added $line to $TMP_SCRIPT"
			fi
		elif [[ "$(awk '{$1=$1};1' <<< "$line")" == "<!-- contate:" ]]; then
			IS_C=false
			TMP_SCRIPT=$(mktemp)
			dbg "started $TMP_SCRIPT"
		else
			CONTATED_FILE+="$line"'\n'
			dbg "0-script line: $line"
		fi
	done < "$FILE_TO_CONTATE"
	dbg "File processed"
	# nice to check contents of target too and see if they are the same
	# then we can preserve access-time
	if [ -n "$2" ];	then
		echo -ne "${CONTATED_FILE}" > $2
	elif [ "$PRINT" = "true" ]; then
		echo -ne "${CONTATED_FILE}"
	fi
}
if [ ! "$1" = "--inherit" ]; then
	unset OUTPUT
	unset PRINT
	unset RECURSE
	unset DEBUG
	unset QUIET
	unset COPY_ARG
	unset EXCLUDE
else 
	shift
fi
unset TARGET
unset SCRIPTDIR
unset VARIABLE_ARG

while [ "$1" ] ; do
	dbg "Process: $1"
	case "$1" in
	'-i'|'--input')
		TARGET=$2	
		if [ -d "$TARGET" ]; then
			ROOT_INPUT_DIR=$(realpath $TARGET)
		fi
		shift 2
		;;
	'--inherit')
		usage "--inherit must be first"
		;;
	'-o'|'--output')
		OUTPUT=$2
		if  test ! -f "$OUTPUT" && test ! -d "$OUTPUT"; then
			if [ ! -d "$(dirname $OUTPUT)" ]; then
				usage "Output is neither file nor directory"
			fi
		fi
		PRINT=false
		shift 2
		;;
	'-p'|'--print')
		PRINT=true
		OUTPUT=""
		shift 1
		;;
	'-r'|'--recursive')
		RECURSE=true
		shift 1
		;;
	'-d'|'--debug')
		DEBUG=true	
		shift 1
		;;
	'-e'|'--exclude')
		EXCLUDE="$2"
		shift 2
		;;
	'-q'|'--quiet')
		QUIET=true
		shift 1
		;;
	# contate expects to take a target, and then process it, this seems silly
	'-s'|'--script')
		SCRIPTDIR=$2
		shift 2
		;;
	'-v'|'--var')
		VARIABLE_ARG=$2
		shift 2	
		;;
	'-c'|'--copy')
		COPY_ARG+="$2"
		dbg "copy args: $COPY_ARG"
		shift 2
		;;
	*)
		usage "What is this: $1?"	
	;;
	esac
done

#add a way to copy all non-ascii files automatically
if test -z "$PRINT" && test -z "$OUTPUT" && test -z "$VARIABLE_ARG"; then
	usage "You need to specify file output or stdout"
elif test -z "$TARGET" && test -z "$SCRIPTDIR" && test -z "$VARIABLE_ARG" ; then
	usage "You need either an input file (-i) a script to run (-s) or a variable to un/set (-v)"
elif [ -n "$TARGET" ]; then
	if test -f "${TARGET}" || test -d "${TARGET}";	then
		dbg "Directory or File: ${TARGET}"	
		if [ -f "${TARGET}" ];	then
			dbg "Target is a File"
			if [ -d "${OUTPUT}" ]; then
				dbg "Output is directory"
				COPIED_PATH=""
				if [ -n "$ROOT_INPUT_DIR" ]; then
					dbg "Input was directory so trying to process copyable path suffix"
					COPIED_PATH=$(echo $(dirname $(realpath $TARGET)) | sed "s|${ROOT_INPUT_DIR}||" )/
				fi
				mkdir -p ${OUTPUT}/${COPIED_PATH}
				SPECIFIC_OUTPUT="${OUTPUT}/${COPIED_PATH}$(basename ${TARGET})"
			else
				SPECIFIC_OUTPUT="${OUTPUT}"
			fi
			dbg "Specific Output: $SPECIFIC_OUTPUT"
# check if target is in copy, and just copy it
# check if all non asci are in copy
			if test ! "$PRINT" = "true" && cmp $(realpath ${TARGET}) "$COPY_ARG"; then
				dbg "Print: $PRINT"
				cp ${TARGET} ${SPECIFIC_OUTPUT}
			elif file ${TARGET} | grep ASCII -qI &>/dev/null; then
				dbg "GOING INTO CONTATE FUNCTION"
				contate_file ${TARGET} ${SPECIFIC_OUTPUT}
			else
				exit
			fi
		fi
		if [ -d ${TARGET} ]; then
			dbg "Target is directory"
			if test -n "${OUTPUT}" && test ! -d "${OUTPUT}"; then
				usage "Target is a directory, so output must be a directory or empty w/ --print"
			fi
			if [ ${RECURSE} ];	then
#must add excludes
				dbg "executing find on $(realpath ${TARGET}) with ${0} --inherit -i"
				find $(realpath ${TARGET}) -name '*' -not -path '*/\.*' -not -name 'Makefile' -not -name '*.contate' -not -path '*/*contate/*' -type f $EXCLUDE -exec ${0} --inherit -i {} \;
			else
				usage	"Target is a directory but recurse is not set (-r)"
				exit
			fi
		fi
	else
		if ! $QUIET; then
			exit "${TARGET} does not exist"
		else
			exit
		fi
	fi
elif [ -n "$VARIABLE_ARG" ]; then
	if grep -e "=" <<< $VARIABLE_ARG; then
		setvar "$(echo $VARIABLE_ARG | cut -d "=" -f 1)" "$(echo $VARIABLE_ARG | cut -d "=" -f 2)"
	else
		echo $(getvar $VARIABLE_ARG)
	fi
elif [ -n "$SCRIPTDIR" ]; then
	exit "This is not supported yet and I don't know why I thought I needed it"
fi

if $TMP_OWNER; then
	rm $TMP_VAR
	dbg "rmed"
fi
