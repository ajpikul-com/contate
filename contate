#!/bin/bash

if [ -z "${TMP_VAR}" ]; then
	export TMP_VAR
	TMP_VAR="$(mktemp)"
	TMP_OWNER=true
else
	unset TMP_OWNER
fi
dbg(){
	if [ "$DEBUG" = true ]; then
		>&2 echo "$1"
	fi
}

err(){
	if [ "$QUIET" = true ]; then
		>&2 echo "$1"
	fi
}

usage(){
	echo "Usage: $1" 1>&2
	if "$TMP_OWNER" && test -f "$TMP_VAR"; then
		rm "$TMP_VAR"
		dbg "rmed $TMP_VAR"
	fi
	exit
}

# 1- file name
# 2- what to compare it against
cmp(){
	dbg "Check cmp $1 $2"
	for i in $2; do
		dbg "$i = $1"
		if [ "$i" -ef "$1" ]; then
			dbg "copying!"
			return 0
		fi
	done
	return 1
}

setvar(){
	dbg "Setting var"
	if [ -f "${TMP_VAR}" ]; then
		if grep "${TMP_VAR}" -e "$1="; then
			sed -i "${TMP}" -e "s/${1}=.*/{$1}=${2}/"
		else
			echo "${1}=${2}" >> "${TMP_VAR}"
		fi
		dbg "temp file:"
		dbg "$(cat "${TMP_VAR}")"
		dbg "temp file<-:"
	else
		exit
	fi
}
getvar(){
	if [ -f "${TMP_VAR}" ]; then
		dbg "find $1 in cat: $(cat "${TMP_VAR}")"
		dbg "grep: $(grep "${TMP_VAR}" -e "$1=")"
		grep "${TMP_VAR}" -e "$1=" | cut -d '=' -f 2-
	fi
}

# 1- Target file
# 2- Output file
contate_file(){ 
	TARGET="$1"
	unset CONTATED_FILE
	if [ "$(grep "$TARGET" -ce "<!-- contate:")" -ne "$(grep "$TARGET" -ce ":contate -->")" ]; then
		err 'You don'\''t have an equal number of "<!-- contate:" and ":contate --!>"'
	fi
	dbg "Contating a file... $TARGET"
	while IFS='' read -r line || [[ -n "$line" ]]; do
		if [ -n "${TMP_SCRIPT}" ]; then
			dbg "Analyzing $line"
			##find and include a suffix
			if [[ "$(awk '{$1=$1};1' <<< "$line")" == ":contate -->" ]]; then
				dbg "Ended a script"
				chmod +x "$TMP_SCRIPT"
				if [ "$IS_C" = true ]; then
					mv "$TMP_SCRIPT" "$TMP_SCRIPT".c
					TMP_SCRIPT="$TMP_SCRIPT".c
				fi
				SCRIPT_OUTPUT="$($TMP_SCRIPT)"
				while IFS='' read -r newline; do
					CONTATED_FILE+="$INDENTATION""$newline"'\n'
				done <<< "$SCRIPT_OUTPUT"
				#CONTATED_FILE+="$($TMP_SCRIPT)"'\n'
				rm "$TMP_SCRIPT"
				unset TMP_SCRIPT
				unset INDENTATION
				unset INDENT_FOUND
				unset SCRIPT_OUTPUT
				unset IS_C
			else
				if grep -qe "tcc -run" <<< "$line"; then
					IS_C=true
				fi
				if grep -qe '#!/' <<< "$line" && test ! "$INDENT_FOUND" = true; then
					INDENTATION="$(cut -d '#' -f 1 <<< "$line")"
					INDENT_FOUND=true
				fi
				echo "${line#$INDENTATION}" >> "$TMP_SCRIPT"
				dbg "Script line added... ${line#$INDENTATION}"
			fi
		elif [[ "$(awk '{$1=$1};1' <<< "$line")" == "<!-- contate:" ]]; then
			##find and include a prefix
			TMP_SCRIPT="$(mktemp)"
			dbg "Found a script! $TMP_SCRIPT"
		else
			dbg "Ascii line added... $line"
			CONTATED_FILE+="$line"'\n'
		fi
		dbg "next line of $TARGET"
	done < "$TARGET"
	dbg "Finished contating file, outputing..."	
	if [ -n "$2" ];	then
		echo -ne "${CONTATED_FILE}" > "$2"
	elif [ "$PRINT" = true ]; then
		echo -ne "${CONTATED_FILE}"
	fi
}
if [ ! "$1" = "--inherit" ]; then
	unset OUTPUT
	unset PRINT
	unset RECURSE
	unset DEBUG
	unset QUIET
	unset COPY_ARG
	unset EXCLUDE
else 
	shift
fi
unset TARGET
unset SCRIPTDIR
unset VARIABLE_ARG

while [ "$1" ] ; do
	dbg "Process: $1"
	case "$1" in
	'-i'|'--input')
		TARGET="$2"
		if [ -d "$TARGET" ]; then
			ROOT_INPUT_DIR="$(realpath "$TARGET")"
		fi
		shift 2
		;;
	'--inherit')
		usage "--inherit must be first"
		;;
	'-o'|'--output')
		export OUTPUT="$2"
		if  test ! -f "$OUTPUT" && test ! -d "$OUTPUT"; then
			if [ ! -d "$(dirname "$OUTPUT")" ]; then
				usage "Output is neither file nor directory"
			fi
		fi
		unset PRINT
		shift 2
		;;
	'-p'|'--print')
		export PRINT=true
		unset OUTPUT	
		shift 1
		;;
	'-r'|'--recursive')
		export RECURSE=true
		shift 1
		;;
	'-d'|'--debug')
		export DEBUG=true	
		shift 1
		;;
	'-e'|'--exclude')
		export EXCLUDE="$2"
		shift 2
		;;
	'-q'|'--quiet')
		export QUIET=true
		shift 1
		;;
	# contate expects to take a target, and then process it, this seems silly
	'-s'|'--script')
		SCRIPTDIR="$2"
		shift 2
		;;
	'-v'|'--var')
		VARIABLE_ARG="$2"
		shift 2	
		;;
	'-c'|'--copy')
		export COPY_ARG+="$2"
		shift 2
		;;
	*)
		usage "Usage: What is this that came through your arguments: $1"	
	;;
	esac
done

#add a way to copy all non-ascii files automatically
if test -z "$PRINT" && test -z "$OUTPUT" && test -z "$VARIABLE_ARG"; then
	usage "You need to specify file output (-o) or stdout (-p) or variable (-v)"
elif test -z "$TARGET" && test -z "$SCRIPTDIR" && test -z "$VARIABLE_ARG" ; then
	usage "You need either an input file (-i) a script to \
					run (-s) or a variable to un/set (-v)"
elif [ -f "${TARGET}" ];	then
	if [ -d "${OUTPUT}" ]; then
		COPIED_PATH=""
		if [ -n "$ROOT_INPUT_DIR" ]; then
			COPIED_PATH="$(sed "s|${ROOT_INPUT_DIR}||" <<< "$(dirname "$(realpath "$TARGET")")" )"/
		fi
		mkdir -p "${OUTPUT}"/"${COPIED_PATH}"
		SPECIFIC_OUTPUT="${OUTPUT}"/"${COPIED_PATH}""$(basename "${TARGET}")"
	else
		SPECIFIC_OUTPUT="${OUTPUT}"
	fi
	if cmp "$(realpath "${TARGET}")" "$COPY_ARG"; then
		if test ! "$PRINT" = true; then
			cp "${TARGET}" "${SPECIFIC_OUTPUT}"
		else
			cat "${TARGET}"
		fi
	elif file "${TARGET}" | grep ASCII -qI &>/dev/null; then
		contate_file "${TARGET}" "${SPECIFIC_OUTPUT}"
	elif test "$COPY_ALL_NASCII" = true && test ! "${PRINT}" = true; then
		cp "${TARGET}" "${SPECIFIC_OUTPUT}"	
	else
		err "Found non-ascii files to be contated without \
					a flag to copy all non-ascii files or tried to \
					print a non-ascii file"
	fi
elif test -d "${TARGET}" ; then
	if test -n "${OUTPUT}" && test ! -d "${OUTPUT}"; then
		usage "Target is a directory, so output must be a directory or empty w/ --print"
	elif test ! "${RECURSE}" = true;	then
		usage "Target is a directory, set -r"
	fi
	find "$(realpath "${TARGET}")" -name '*' -not -path '*/\.*' -not -name 'Makefile' -not -name '*.contate' -not -path '*/*contate/*' -type f $EXCLUDE -exec "${0}" --inherit -i {} \;
# not the way to handle variable args
elif [ -n "$VARIABLE_ARG" ]; then
	if grep -e "=" <<<"$VARIABLE_ARG"; then
		setvar "$(echo "$VARIABLE_ARG" | cut -d "=" -f 1)" "$(echo "$VARIABLE_ARG" | cut -d "=" -f 2)"
	else
		getvar "$VARIABLE_ARG"
	fi
elif [ -n "$SCRIPTDIR" ]; then
	exit "This is not supported yet and I don't know why I thought I needed it"
fi

if [ "$TMP_OWNER" = true ]; then
	rm "$TMP_VAR"
	dbg "rmed $TMP_VAR"
fi
